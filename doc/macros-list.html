<!DOCTYPE html>
<html>
	<head>
		<!-- Title -->
		<title>List of Macros | C Container Collection</title>

		<!-- CSS -->
		<style type="text/css">
		table
		{
			margin: 16px auto;
			border-style: 1px solid;
			border-collapse: collapse;
		}
		th
		{
			height: 32px;
		}
		th, td
		{
			border: 1px solid;
			padding: 5px;
			white-space: pre;
		}
		th, td:nth-child(-n+2)
		{
			text-align: center;
			font-weight: normal;
			font-family: "Helvetica";
		}
		td:nth-child(3)
		{
			border-right-style: hidden;
			font-family: monospace;
		}
		td:nth-child(4)
		{
			border-left-style: hidden;
			font-family: monospace;
		}
		td:nth-child(n+5)
		{
			font-family: "Times New Roman";
		}
		td:nth-child(6)
		{
			text-align: center;
		}
		</style>
	</head>

	<body>
		<!-- HTML -->
		<table>
		<tbody>
			<tr>
				<th rowspan="2">Container</th>
				<th colspan="3">Operation</th>
				<th rowspan="2">Short Description</th>
			</tr>
			<tr>
				<th style="display:none"></th>
				<th>Category</th><th colspan="2">Function-like Macros Prototype</th>
				<th style="display:none"></th>
			</tr>
			<tr>
				<td rowspan="38">CCXLL</td>
				<td rowspan="4">Create</td><td> <u><i>struct</i></u></td><td>ccxll (TYPE) CCXLL;</td>
				<td>Create a ccxll container of type <font face="monospace">TYPE</font>.</br>Use a C struct to simulate a list container.</td>
			</tr>
			<tr>
				<td style="display:none"></td>
				<td style="display:none"></td><td> <u><i>struct</i></u></td><td>ccxll_iter (TYPE) ITER;</td>
				<td>Create an iterator for the ccxll container of type <font face="monospace">TYPE</font>.</br>The iterator might be invalid if the container is modified.</td>
			</tr>
			<tr>
				<td style="display:none"></td>
				<td style="display:none"></td><td> <u><i>struct</i></u></td><td>ccxll_pckd (TYPE) CCXLL;</td>
				<td>Create a packed ccxll container of type <font face="monospace">TYPE</font>.</br>This decreases memory usage as much as possible.</td>
			</tr>
			<tr>
				<td style="display:none"></td>
				<td style="display:none"></td><td> <u><i>struct</i></u></td><td>ccxll_iter_pckd (TYPE) ITER;</td>
				<td>Create an iterator for packed ccxll containers of type <font face="monospace">TYPE</font>.</br>This should be used by every packed ccxll container to make sure the correctness.</td>
			</tr>
			<tr>
				<td style="display:none"></td>
				<td rowspan="2">Initialize</td><td> void</td><td>ccxll_init (CCXLL);</td>
				<td>Initialize the ccxll container.</br>CAUTION: Every container should be initialized right after its creation.</td>
			</tr>
			<tr>
				<td style="display:none"></td>
				<td style="display:none"></td><td> void</td><td>ccxll_iter_init (ITER, CCXLL);</td>
				<td>Initialize the iterator for the ccxll container.</br>CAUTION: Every iterator should be initialized right after its creation.</td>
			</tr>
			<tr>
				<td style="display:none"></td>
				<td rowspan="1">Destroy</td><td> <u><i>stat</i></u></td><td>ccxll_free (CCXLL);</td>
				<td>Deallocate all elements in the container manually.</br>CAUTION: Every container should be destroyed before the program terminates.</td>
			</tr>
			<tr>
				<td style="display:none"></td>
				<td rowspan="2">Access</td><td> TYPE&amp;</td><td>ccxll_front (CCXLL);</td>
				<td>Return a reference to the first element.</br>It's an undefined behavior if the container is empty.</td>
			</tr>
			<tr>
				<td style="display:none"></td>
				<td style="display:none"></td><td> TYPE&amp;</td><td>ccxll_back (CCXLL);</td>
				<td>Return a reference to the last element.</br>It's an undefined behavior if the container is empty.</td>
			</tr>
			<tr>
				<td style="display:none"></td>
				<td rowspan="2">Capacity</td><td> int</td><td>ccxll_size (CCXLL);</td>
				<td>Return the number of the elements in the container.</br>Return 0 if the container is empty.</td>
			</tr>
			<tr>
				<td style="display:none"></td>
				<td style="display:none"></td><td> int</td><td>ccxll_empty (CCXLL);</td>
				<td>Check whether the container is empty.</br>Return 1 if the container is empty, and return 0 if it is not.</td>
			</tr>
			<tr>
				<td style="display:none"></td>
				<td rowspan="7">Modifiers</td><td> <u><i>stat</i></u></td><td>ccxll_push_front (CCXLL, <b>value</b>);</td>
				<td>Insert an element at the beginning.</br>This makes a copy of <b><font face="monospace">value</font></b> into the container.</td>
			</tr>
			<tr>
				<td style="display:none"></td>
				<td style="display:none"></td><td> <u><i>stat</i></u></td><td>ccxll_push_back (CCXLL, <b>value</b>);</td>
				<td>Insert an element at the end.</br>This makes a copy of <b><font face="monospace">value</font></b> into the container.</td>
			</tr>
			<tr>
				<td style="display:none"></td>
				<td style="display:none"></td><td> <u><i>stat</i></u></td><td>ccxll_pop_front (CCXLL);</td>
				<td>Remove the first element.</br>There is nothing modified if the container is empty.</td>
			</tr>
			<tr>
				<td style="display:none"></td>
				<td style="display:none"></td><td> <u><i>stat</i></u></td><td>ccxll_pop_back (CCXLL);</td>
				<td>Remove the last element.</br>There is nothing modified if the container is empty.</td>
			</tr>
			<tr>
				<td style="display:none"></td>
				<td style="display:none"></td><td> <u><i>stat</i></u></td><td>ccxll_clear (CCXLL);</td>
				<td>Remove all elements in the container.</br>This does not deallocate all elements in the container.</td>
			</tr>
			<tr>
				<td style="display:none"></td>
				<td style="display:none"></td><td> <u><i>stat</i></u></td><td>ccxll_insert (ITER, <b>value</b>);</td>
				<td>Insert an element at the position where the iterator points.</br>This makes a copy of <b><font face="monospace">value</font></b> into the container.</td>
			</tr>
			<tr>
				<td style="display:none"></td>
				<td style="display:none"></td><td> <u><i>stat</i></u></td><td>ccxll_erase (ITER);</td>
				<td>Erase an element at the position where the iterator points.</br>There is nothing modified if the container is empty.</td>
			</tr>
			<tr>
				<td style="display:none"></td>
				<td rowspan="4">Operations</td><td> <u><i>stat</i></u></td><td>ccxll_move_range (ITER_P, ITER_L, ITER_R);</td>
				<td>Move the elements in the range <font face="monospace">[ITER_L, ITER_R)</font> to position where <font face="monospace">ITER_P</font> points.</br>These three iterators should be affiliated to the same ccxll container.</td>
			</tr>
			<tr>
				<td style="display:none"></td>
				<td style="display:none"></td><td> <u><i>stat</i></u></td><td>ccxll_merge_range (ITER_L, ITER_M, ITER_R, ITER_X);</td>
				<td>Merge two sorted segments in the range <font face="monospace">[ITER_L, ITER_M)</font> and <font face="monospace">[ITER_M, ITER_R)</font>.</br>This requires an auxiliary iterator <font face="monospace">ITER_X</font> which is not in use currently.</td>
			</tr>
			<tr>
				<td style="display:none"></td>
				<td style="display:none"></td><td> <u><i>stat</i></u></td><td>ccxll_sort (CCXLL, &(ITER_X[4]));</td>
				<td>Sort all elements with default comparator <font face="monospace">CCXLL_DEFAULT_LEQ_COMPARATOR</font>.</br>This requires a pointer pointing to an array of four auxiliary iterators <font face="monospace">ITER_X[4]</font>.</td>
			</tr>
			<tr>
				<td style="display:none"></td>
				<td style="display:none"></td><td> <u><i>stat</i></u></br> </td><td>ccxll_sort_openmp (CCXLL, &(CCXLL_X[N]), </br>                   &(ITER_X[N][4]), N);</td>
				<td>Sort all elements with default comparator <font face="monospace">CCXLL_DEFAULT_LEQ_COMPARATOR</font>.</br><font face="monospace">N</font> is the max number of threads that will be used for OpenMP parallel computing.</td>
			</tr>
			<tr>
				<td style="display:none"></td>
				<td rowspan="13">Iterators</td><td> TYPE&amp;</td><td>ccxll_iter_dref (ITER);</td>
				<td>Return a reference to the element.</br>It's an undefined behavior if the iterator is not invalid.</td>
			</tr>
			<tr>
				<td style="display:none"></td>
				<td style="display:none"></td><td> void</td><td>ccxll_iter_copy (ITER_DST, ITER_SRC);</td>
				<td>Copy the iterator from <font face="monospace">ITER_SRC</font> to <font face="monospace">ITER_DST</font>.</br>It's not acceptable to assign the iterator by assignment operator.</td>
			</tr>
			<tr>
				<td style="display:none"></td>
				<td style="display:none"></td><td> void</td><td>ccxll_iter_head (ITER, CCXLL);</td>
				<td>Set the iterator to the head of the container.</br>The head of the container is the sentinel node that points to the first element.</td>
			</tr>
			<tr>
				<td style="display:none"></td>
				<td style="display:none"></td><td> void</td><td>ccxll_iter_tail (ITER, CCXLL);</td>
				<td>Set the iterator to the tail of the container.</br>The tail of the container is the sentinel node that points to the last element.</td>
			</tr>
			<tr>
				<td style="display:none"></td>
				<td style="display:none"></td><td> void</td><td>ccxll_iter_begin (ITER, CCXLL);</td>
				<td>Set the iterator to the first element usaully.</br>Set the iterator to the tail if the container is empty.</td>
			</tr>
			<tr>
				<td style="display:none"></td>
				<td style="display:none"></td><td> void</td><td>ccxll_iter_end (ITER, CCXLL);</td>
				<td>Set the iterator to the last element usaully.</br>Set the iterator to the head if the container is empty.</td>
			</tr>
			<tr>
				<td style="display:none"></td>
				<td style="display:none"></td><td> void</td><td>ccxll_iter_at_head (ITER);</td>
				<td>Check whether the iterator points to the head of the container.</br>Return 1 if it is true. Otherwise, return 0.</td>
			</tr>
			<tr>
				<td style="display:none"></td>
				<td style="display:none"></td><td> void</td><td>ccxll_iter_at_tail (ITER);</td>
				<td>Check whether the iterator points to the tail of the container.</br>Return 1 if it is true. Otherwise, return 0.</td>
			</tr>
			<tr>
				<td style="display:none"></td>
				<td style="display:none"></td><td> void</td><td>ccxll_iter_at_begin (ITER, CCXLL);</td>
				<td>Check whether the iterator points to the first element.</br>Return 1 if it is true. Otherwise, return 0.</td>
			</tr>
			<tr>
				<td style="display:none"></td>
				<td style="display:none"></td><td> void</td><td>ccxll_iter_at_end (ITER, CCXLL);</td>
				<td>Check whether the iterator points to the last element.</br>Return 1 if it is true. Otherwise, return 0.</td>
			</tr>
			<tr>
				<td style="display:none"></td>
				<td style="display:none"></td><td> void*</td><td>ccxll_iter_incr (ITER);</td>
				<td>Move the iterator forward by one element.</br>Return NULL iff the iterator doesn't point to any element.</td>
			</tr>
			<tr>
				<td style="display:none"></td>
				<td style="display:none"></td><td> void*</td><td>ccxll_iter_decr (ITER);</td>
				<td>Move the iterator backward by one element.</br>Return NULL iff the iterator doesn't point to any element.</td>
			</tr>
			<tr>
				<td style="display:none"></td>
				<td style="display:none"></td><td> <u><i>stat</i></u></td><td>ccxll_iter_advance (ITER, <b>diff</b>);</td>
				<td>Move the iterator by <b><font face="monospace">diff</font></b> element(s). (set forward as positive)</br>The iterator will stop at the sentinel node if there is no element left to iterate over.</td>
			</tr>
			<tr>
				<td style="display:none"></td>
				<td rowspan="2">Traversal</td><td> <u>loop</u></td><td>CCXLL_FORWARD_TRAVERSAL (CCXLL, ITER) <u><i>stat</i></u>;</td>
				<td>Traverse all elements from the beginning to the end.</br>There is no effect if the container is empty.</td>
			</tr>
			<tr>
				<td style="display:none"></td>
				<td style="display:none"></td><td> <u>loop</u></td><td>CCXLL_BACKWARD_TRAVERSAL (CCXLL, ITER) <u><i>stat</i></u>;</td>
				<td>Traverse all elements (backward) from the end to the beginning.</br>There is no effect if the container is empty.</td>
			</tr>
			<tr>
				<td style="display:none"></td>
				<td rowspan="1">Comparators</td><td> int</td><td>CCXLL_DEFAULT_LEQ_COMPARATOR (ITER_L, ITER_R);</td>
				<td>Compare values by passing and dereferencing two iterators for sorting algorithms.</br>Return 1 if the value pointed by <font face="monospace">ITER_L</font> is not greater than the value pointed by <font face="monospace">ITER_R</font>.</td>
			</tr>
		</tbody>
		</table>
	</body>
</html>
